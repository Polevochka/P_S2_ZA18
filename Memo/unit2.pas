unit Unit2;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils;

// Создадит тип двухмерного массива,
//чтобы можно было передавать матрицы в различные функции

// Причом важно описать этот тип именно в области interface,
// а то данный тип не будет виден в модуле unit1,
// куда подключается наш модуль unit2 с этим типом
type
  Ar1 = array [1..20] of integer; // одномерный массив - СТРОКИ МАТРИЦЫ
  Ar2 = array [1..20] of Ar1; // двумерный массив - МАТРИЦА


// Прототипы функций - просто их заголовки
// - это те функции которые должны быть видны в модуле unit1 - та же причина,
// что и с типом unit1
procedure CreateAr2(var a: Ar2; n : integer; m: integer);
function FindAverage(row: Ar1; m: integer): real;



implementation

{Процедура заполнения матрицы рандомными числами}
//'var a' - т.к. меняем элементы матрицы
//  'n' - число строк
//  'm' - число столбцов
procedure CreateAr2(var a: Ar2; n : integer; m: integer);
var i, j: integer;
begin
   randomize;  // Для генератора случайных чисел - более случайное число
   for i:=1 to n do
       for j:=1 to m do
           a[i,j] := random(100); // рандомное число на отрезке [0;99]
end;

{Функция нахождения среднего арифметического в строке}
// заметьте нет var - ничего не меняем
// 'row': Ar1 - строка матрицы (Ar1 а не Ar2 - тк. СТРОКА - ОДНОМЕРНЫЙ массив)
//        удобно передавать только строку, а не всю матрицу
//        иначе пришлось бы передавать в функцию номер строки.
// 'm' - количество столбцов в строке
function FindAverage(row: Ar1; m: integer): real;
var s: integer; // сумма всех чисел в строке
    j: integer; // индекс столбцов
begin
   // находим сумму элементов в СТРОКЕ( а не во всей матрице)
   s:= 0;
   for j:=1 to m do
       s:= s + row[j];
   // среднее арифметическое - это сумма элементов - 's',
   // делённое на их количество - 'm'
   // присваиваем это значение имени нашей функции -
   // это и есть точто она возвращает

   // заметьте что делим мы '/', а не 'div' - т.к. СРЕДНЕЕ АРИФМЕТИЧЕСКОЕ
   // это ВЕЩЕСТВЕННОЕ ЧИСЛО
   FindAverage := s/m;
end;

end.

