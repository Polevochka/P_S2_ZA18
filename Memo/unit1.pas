unit Unit1;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,
  unit2;

type

  { TForm1 }

  TForm1 = class(TForm)
    Button1: TButton;
    Button2: TButton;
    Button3: TButton;
    Button4: TButton;
    Memo1: TMemo;
    Memo2: TMemo;
    procedure Button1Click(Sender: TObject);
    procedure Button2Click(Sender: TObject);
    procedure Button3Click(Sender: TObject);
    procedure Button4Click(Sender: TObject);
  private

  public

  end;

var
  Form1: TForm1;

  // Делаем матрицу и её размерность глобальными переменными
  // чтобы они были видны во всех функциях -
  // обработчиков нажатия кнопок
  a: Ar;       // матрица
  n,m : integer; // число строк и столбцов

implementation

{$R *.lfm}

{ TForm1 }

{Нажали 'Закрыть'}
procedure TForm1.Button1Click(Sender: TObject);
begin
  close;
end;

{Нажали 'Создать матрицу'}
procedure TForm1.Button2Click(Sender: TObject);
var
  // строковое представление одного числа
  el_str: string;
  // вспомогательная строка, чтобы добавлять элементы матрицы
  // то есть это сумма строковых представлений каждого элемента(el_str) матрицы
  tmp_str: string;
  i, j: integer; // для перебора строк и столбцов

begin
  // Получаем размерность матрицы от пользователя
  // InputBox возвращает строку, но ГЛОБАЛЬНЫЕ переменные n и m типа integer
  // поэтому преобразуем возвращаем значение в целое число при помощи StrToInt
  n := StrToInt(InputBox('Ввод числа', 'Сколько строк?', '5'));
  m := StrToInt(InputBox('Ввод числа', 'Сколько столбцов?', '5'));

  // Теперь так как УЖЕ ЕСТЬ число строк и столбцов
  // Заполняем матрицу
  CreateAr(a, n, m);


  {выводим матрицу в Memo1 - исходная матрица}

  // сначала мы будем собирать строку из элементов матрицы,
  // лежащих на i-ой строчке
  // Потом добавляем эту строку в Memo1 через Append
  for i:=1 to n do
  begin
    // присваиваем пустую строку про обработке каждой строки матрицы
    // То есть обработали одну строку, очистили переменную, обработать другую
    // иначе элементы с другой (предыдущей) строки будут выводиться и в новой строке
    tmp_str:='';
    for j:=1 to m do
    begin
      // преобразуем елемент матрицы в строку
      // число 5 - так же как и в writeln - ширина поля под число
      // чтобы не замарачиваться с пробелами при выводе
      str(a[i,j]:5, el_str);
      // по одному элементы i-ой строки собираем в одну строку
      tmp_str := tmp_str + el_str;
    end;
    // собрали одну строку, теперь добавляем её в Memo1
    Memo1.Append(tmp_str);

    // Переходим к другим строкам
  end;
end;

{Нажали 'Обработка'}
procedure TForm1.Button3Click(Sender: TObject);
var i, j: integer; // для перебора столбцов и строк
    ave: real; // Среднее арифметическое одной строки матрицы
    ave_str: string; // СТРОКОВОЕ представление среднего арифметического
    k: integer; // число которое вводит пользователь (Среднее должно быть БОЛЬШЕ него)
    sreds_str: string; // Строка средних чисел СТОЛБЦОВ
    // строковое представление одного числа
    el_str: string;
    // вспомогательная строка, чтобы добавлять элементы матрицы
    // то есть это сумма строковых представлений каждого элемента(el_str) матрицы
    tmp_str: string;
begin

  // Переменные a, n, m - глобальне переменны, которые видны во всех процедурах
  // их значения должны быть УЖЕ ЗАДАНЫ при нажатии кнопки {Создать матрицу}

  {Добавляем столбик со Средними арифметическими числами каждой строки в Memo1}
  // обходим строки матрицы
  for i:=1 to n do
  begin
    // Находим Среднее арифметическое чисел в i-ой строке
    ave := FindAveRow(a, m, i);
    // В Мемо можно записать только строки
    // FindAverage - возвращет вещественно число
    // Нужно преобразовать это число к типу строк при помощи процедуры str
    // ave:10:2 - числа после функции - тоже самое, что и
    // при выводе при помощи writeln
    // 10 - сколько отводится места на всё число
    // 2 - количество значащих чиел после запятой
    // например writeln(float_number:10:2);
    // float_number в нашем случае - то,
    // что вернёт вызов функции FindAverage(a[i], m) - значение переменной 'ave'
    str(ave:10:2, ave_str);
    // добавляем к каждой строке в Memo справа - это число
    Memo1.Lines[i-1] := Memo1.Lines[i-1] + ave_str;
  end;

  {Защита}
  {
  {Добавляем строку со Средними арифметическими числами каждого столбца в Memo1}
  sreds_str := '';
  for j:= 1 to m do
  begin
    // Находим среднее число j-ого столбца
    ave := FindAveCol(a, n, j);
    // Преобразуем его в строку
    str(ave:8:2, ave_str);
    // Собираем строку средних значений столбцов добавляя по одному
    sreds_str := sreds_str + ave_str;
  end;
  // Теперь можно добавить собранную строку Средних значений столбцов в Memo1
  Memo1.Append(sreds_str);
  }


  // Получаем число, от польователя, чтобы понять
  // какие строки печатать в Memo2
  // Среднее Арифметическое этих строк БОЛЬШЕ этого числа
  k := StrToInt(InputBox('Обработка', 'Введите число', '50'));

  // В зависимости от K выводим в Memo1 нужные элементы матрицы

  {Выводим СТРОКИ}
  for i:= 1 to n do
  begin
    // Если СРЕДНЕЕ СТРОКИ БОЛЬШЕ введённого пользователем числа 'K'
    // То этe строку нужно вывести в Memo2
    if FindAveRow(a, m, i) > k then
    begin
      tmp_str:='';
      for j:=1 to m do
      begin
        // преобразуем елемент матрицы в строку
        // число 5 - так же как и в writeln - ширина поля под число
        // чтобы не замарачиваться с пробелами при выводе
        str(a[i,j]:5, el_str);
        // по одному элементы i-ой строки собираем в одну строку
        tmp_str := tmp_str + el_str;
      end;
      // собрали одну строку, теперь добавляем её в Memo2 - Результат
      Memo2.Append(tmp_str);

    // Переходим к другим строкам
    end;
  end;

  {Защита}
  {
  {Выводим СТОЛБЦЫ}
  for j:=1 to m do
  begin
    // Если СРЕДНЕЕ СТОЛБЦА БОЛЬШЕ введённого пользователем числа 'K'
    // То этот столбец выводим в Memo2 - результат
    if FindAveCol(a, n, j) > k then
      for i:= 1 to n do
      begin
        // преобразуем елемент матрицы в строку
        // число 5 - так же как и в writeln - ширина поля под число
        // чтобы не замарачиваться с пробелами при выводе
        str(a[i,j]:5, el_str);
        Memo2.Lines[i-1] := Memo2.Lines[i-1] + el_str
      end;
  end;
  }
end;


{Нажали 'Очистить'}
procedure TForm1.Button4Click(Sender: TObject);
begin
  // Нужно очистить два текстовых поля
  // реализация очистки есть внутри этих объектов
  Memo1.Clear;
  Memo2.Clear;
end;

end.

